type Post @mock {
  id: ID! @mockfn(name: "List", values: ["1", "2"])
  title: String! @mockfn(name: "List", values: ["Hello world!", "Another blog"])

  content: String!
    @mockfn(
      name: "List"
      values: [
        "<p>There are two reasons why our first release uses GraphQL as the 'One API for all Your Data.'</p><h2>GraphQL is better for a frontend developer</h2><p>A couple of months into StepZen’s journey, we realized two things:</p><ol><li><p>Frontend developers are beginning to adopt GraphQL as the way to get data from backends, which is the raison d’etre for StepZen. The <a title='2019 State of JavaScript survey' href='https://2019.stateofjs.com/'>2019 State of JavaScript survey</a> for example reports that <a href='https://2019.stateofjs.com/data-layer/'>almost 40% of respondents have 'used GraphQL, and would use it again'</a>, up from 20% in the 2018 survey; 50% of respondents have 'heard of it, and would like to learn it.'</p></li><li><p>The cognitive overload in understanding the schema and query structures in GraphQL is low--and there is enough open source tooling that helps along the way. There are no <a href='https://swagger.io/resources/open-api/'>Open API</a> to read: open up your favorite tool (such as <a href='https://github.com/graphql/graphql-playground'>GraphQL Playground</a>, or <a href='https://github.com/graphql/graphiql'>GraphiQL</a>), and you have live documentation! In traditional REST calls--what you call and what you get back are only vaguely related: you have to parse the returned JSON and extract the bits yoy are interested in; whereas in GraphQL, what you get back is what you asked for (the shape of the response is the shape of the query). This is an awesome reduction in the cognitive overload on the frontend developer.</p></li></ol><h2>GraphQL is better for a backend developer</h2><p>There are technical reasons too as to why GraphQL is simply better as a universal API. This makes the job of the backend developer easier.</p><h3>Why REST as 'One API for all your Data' leaves a lot of holes and GraphQL fixes most of these.</h3><p>A REST API that would be 'One API for all Your Data' would look something like this:</p><pre class=' language-bash'><code class=' language-bash'>/oneAPI?q<span class='token operator'>=</span><span class='token string'>'select x where y'</span></code></pre><p>As an example, x could be <code>orders.productTitle</code> and y could be <code>customers.email=johndoe@example.com</code>. But that immediately begs the question: what values of x are allowed, and what values of y are allowed, and what combination of these values are allowed?In relational databases, all queries are executable, some fast, some slowly. But in a world where the backends are what the backends are, this is no longer true. To show this, consider a query where</p><pre class=' language-bash'><code class=' language-bash'>y:products.Id<span class='token operator'>=</span><span class='token number'>2</span>x:customers.email</code></pre><p>This is a perfectly valid request: let us say that a product with <code>id=2</code> is recalled, and we might want to send mail to all customers who have bought the product.</p><p>However, typical backends are able to give data on what products a particular customer has bought, not which customers bought a particular product. Consequently, the above query might be very inefficient to execute (look through all orders of all customers and return those customers who had that particular product), or might not be executable at all.</p><p>So now, the backend developer must ensure that the frontend developer does not ask bad queries, and also, there are enough IDE integrations so that invalid queries are disallowed. So more work, more autogenerated code, longer and longer names of functions as helpers: <code>getProductDetailsByCustomerId</code> etc. All the stuff of nightmares.</p><p>This is much easier to solve in GraphQL. If the schema said:</p><pre class=' language-graphql'><code class=' language-graphql'><span class='token keyword'>type</span> <span class='token class-name'>Customer</span> <span class='token punctuation'>{</span>  <span class='token attr-name'>email</span><span class='token punctuation'>:</span> String  …  <span class='token attr-name'>products</span><span class='token punctuation'>:</span> <span class='token punctuation'>[</span>Product<span class='token punctuation'>]</span><span class='token punctuation'>}</span></code></pre><p>and there is nothing in the schema like</p><pre class=' language-graphql'><code class=' language-graphql'><span class='token keyword'>type</span> <span class='token class-name'>Product</span> <span class='token punctuation'>{</span>  <span class='token attr-name'>id</span><span class='token punctuation'>:</span> Int  …  <span class='token attr-name'>customers</span><span class='token punctuation'>:</span> <span class='token punctuation'>[</span>Customer<span class='token punctuation'>]</span><span class='token punctuation'>}</span></code></pre><p>Then the first query is executable, and the second query, simply by being absent in the schema, is not!</p><h3>GraphQL makes stitching easier</h3><p>If a backend developer wants to stitch multiple pieces of data together (say customer details with all his orders), and return them in one call, she has two choices:</p><ul><li>Default to returning the stitched data (which would be wasted work if the frontend developer did not want that data), or</li><li>She adds artificial parameters like <code>return=customer,orders</code> which introduce cruft and cognitive overload.</li></ul><p>Instead, in GraphQL, introspection will tell the frontend developer whether she can query stitched data together (so, no cruft of artifical parameters), and would also let the developer ask or not ask for stitched data.</p><p>That is why, in our current release, and all near-term releases, we only expose GraphQL as the interface--GraphQL is better for the frontend developer, and GraphQL is better for exposing backends. It is the right choice for 'One API for all Your Data.'</p>"
        "<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&#8217;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged.</p> "
      ]
    )
  excerpt: String!
    @mockfn(
      name: "List"
      values: [
        "<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&#8217;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into [&hellip;]</p>"
        "<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&#8217;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into [&hellip;]</p>"
      ]
    )

  image: String
    @mockfn(
      name: "List"
      values: [
        "https://placekitten.com/200/300"
        "https://placekitten.com/200/400"
      ]
    )

  authorId: ID! @mockfn(name: "List", values: ["1", "1"])
  author: Author
    @materializer(
      query: "getAuthorById"
      arguments: [{ name: "id", field: "authorId" }]
    )

  published: DateTime!
}

type Query {
  getPosts: [Post]
  getPostById(id: ID!): Post
}
